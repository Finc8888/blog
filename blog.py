#1.)Сперва мы добавим в blog.py импортирование модулей:

# все импорты
import sqlite3
import os
from flask import Flask, request, session, g, redirect, url_for, abort, \
     render_template, flash

# конфигурация
DATABASE = '/tmp/blog.db'
DEBUG = True
SECRET_KEY = 'development key'
USERNAME = 'admin'
PASSWORD = 'default'

#2.)Далее, мы должны создать наше текущее приложение и инициализировать его c помощью конфигурации из того же файла, т. е. blog.py:

# создаём наше маленькое приложение :)
app = Flask(__name__)
app.config.from_object(__name__)#можно использовать метод from_object() объекта конфигурации, указавему имя импортируемого модуля.
#Flask проинициализирует переменную из этого модуля.
#В любом случае будут учтены только имена переменных, заданные в верхнем регистре.

# Загружаем конфиг по умолчанию и переопределяем в конфигурации часть
# значений через переменную окружения
app.config.update(dict(
    DATABASE=os.path.join(app.root_path, 'blog.db'),
    DEBUG=True,
    SECRET_KEY='development key',
    USERNAME='admin',
    PASSWORD='default'
))
app.config.from_envvar('BLOG_SETTINGS', silent=True)
"""3.)Добавим также метод, который позволяет простым способом соединиться с указанной базой данных.
Он может быть использован для открытия соединения по запросу, а также из интерактивной командной оболочки Python или из скрипта.
Это пригодится в дальнейшем. Мы создаём простое соединение с базой данных SQLite и далее просим его использовать для представления
строк объект sqlite3.Row. Это позволит нам рассматривать строки, как если бы они были словарями, а не кортежами."""

def connect_db():
    """Соединяет с указанной базой данных."""
    rv = sqlite3.connect(app.config['DATABASE'])
    rv.row_factory = sqlite3.Row
    return rv
"""5.) Создание и закрытие соединения с базой данных каждый раз - очень неэффективно, поэтому мы хотели бы держать его подольше.
 Поскольку соединения с базой данных инкапсулирует транзакцию, нам также надо убедиться,
 что в один момент времени соединением пользуется только один запрос.
 В этом месте в игру вступает контекст приложения.
 Переменная request - это объект запроса, ассоциированный с текущим запросом,
 в то время как g - это переменная общего назначения, которая ассоциирована с текущим контекстом приложения.
 Можно безопасно сохранять информацию в объекте g.
 Чтобы сделать это, можно сделать функцию-помощник (helper). Когда она будет запущена в первый раз,
 она создаст для текущего контекста соединение с базой данных, и её успешные вызовы будут возвращать уже установленное соединение:"""
def get_db():
    """Если ещё нет соединения с базой данных, открыть новое - для
    текущего контекста приложения
    """
    if not hasattr(g, 'sqlite_db'):
        g.sqlite_db = connect_db()
    return g.sqlite_db
"""6.)Для разрыва соединения Flask обеспечил нас декоратором teardown_appcontext().
Он выполняется каждый раз, когда происходит разрыв контекста приложения.
Функция, обозначенная как teardown_appcontext() вызывается каждый раз при разрыве контекста приложения.
В сущности, контекст приложения уже создан до того, как пришёл запрос, и он уничтожается (разрывается) когда запрос заканчивается.
Разрыв может произойти по двум причинам: или всё прошло хорошо (параметр ошибки в этом случае будет None),
или произошло исключение, и в этом случае функции разрыва будет передана ошибка.
"""
@app.teardown_appcontext
def close_db(error):
    """Closes the database again at the end of the request."""
    if hasattr(g, 'sqlite_db'):
        g.sqlite_db.close()

"""4.)Наконец, мы просто добавляем строчку в конце файла, которая запускает сервер, 
если мы хотим запустить этот файл как отдельное приложение:"""

if __name__ == '__main__':
    app.run()