#1.)Сперва мы добавим в blog.py импортирование модулей:

# все импорты
import sqlite3
import os
from flask import Flask, request, session, g, redirect, url_for, abort, \
     render_template, flash

# конфигурация
DATABASE = '/tmp/blog.db'
DEBUG = True
SECRET_KEY = 'development key'
USERNAME = 'admin'
PASSWORD = 'default'

#2.)Далее, мы должны создать наше текущее приложение и инициализировать его c помощью конфигурации из того же файла, т. е. blog.py:

# создаём наше маленькое приложение :)
app = Flask(__name__)
app.config.from_object(__name__)#можно использовать метод from_object() объекта конфигурации, указавему имя импортируемого модуля.
#Flask проинициализирует переменную из этого модуля.
#В любом случае будут учтены только имена переменных, заданные в верхнем регистре.

# Загружаем конфиг по умолчанию и переопределяем в конфигурации часть
# значений через переменную окружения
app.config.update(dict(
    DATABASE=os.path.join(app.root_path, 'blog.db'),
    DEBUG=True,
    SECRET_KEY='development key',
    USERNAME='admin',
    PASSWORD='default'
))
app.config.from_envvar('BLOG_SETTINGS', silent=True)
"""3.)Добавим также метод, который позволяет простым способом соединиться с указанной базой данных.
Он может быть использован для открытия соединения по запросу, а также из интерактивной командной оболочки Python или из скрипта.
Это пригодится в дальнейшем. Мы создаём простое соединение с базой данных SQLite и далее просим его использовать для представления
строк объект sqlite3.Row. Это позволит нам рассматривать строки, как если бы они были словарями, а не кортежами."""

def connect_db():
    """Соединяет с указанной базой данных."""
    rv = sqlite3.connect(app.config['DATABASE'])
    rv.row_factory = sqlite3.Row
    return rv

"""5.) Создание и закрытие соединения с базой данных каждый раз - очень неэффективно, поэтому мы хотели бы держать его подольше.
 Поскольку соединения с базой данных инкапсулирует транзакцию, нам также надо убедиться,
 что в один момент времени соединением пользуется только один запрос.
 В этом месте в игру вступает контекст приложения.
 Переменная request - это объект запроса, ассоциированный с текущим запросом,
 в то время как g - это переменная общего назначения, которая ассоциирована с текущим контекстом приложения.
 Можно безопасно сохранять информацию в объекте g.
 Чтобы сделать это, можно сделать функцию-помощник (helper). Когда она будет запущена в первый раз,
 она создаст для текущего контекста соединение с базой данных, и её успешные вызовы будут возвращать уже установленное соединение:"""
def get_db():
    """Если ещё нет соединения с базой данных, открыть новое - для
    текущего контекста приложения
    """
    if not hasattr(g, 'sqlite_db'):
        g.sqlite_db = connect_db()
    return g.sqlite_db
"""6.)Для разрыва соединения Flask обеспечил нас декоратором teardown_appcontext().
Он выполняется каждый раз, когда происходит разрыв контекста приложения.
Функция, обозначенная как teardown_appcontext() вызывается каждый раз при разрыве контекста приложения.
В сущности, контекст приложения уже создан до того, как пришёл запрос, и он уничтожается (разрывается) когда запрос заканчивается.
Разрыв может произойти по двум причинам: или всё прошло хорошо (параметр ошибки в этом случае будет None),
или произошло исключение, и в этом случае функции разрыва будет передана ошибка.
"""
@app.teardown_appcontext
def close_db(error):
    """Closes the database again at the end of the request."""
    if hasattr(g, 'sqlite_db'):
        g.sqlite_db.close()
""" 7.)Добавляем функцию, которая иициализировала бы для нашего приложения базу данных.
Контекст приложения создаётся всякий раз при появлении запроса. Если запроса нет, то необходимо создать контекст приложения вручную.
Без контекста приложения объект g не узнает, какому приложению он соответствует, ведь их может быть несколько!

Контекст приложения для нас устанавливает оператор with app.app_context(). В теле оператора with объект g будет проассоциирован
с app. В конце оператора with ассоциация перестанет действовать, и будут запущены все функции разрыва контекста. 
Это значит, что после совершения действия соединение с базой данных будет разорвано.

Метод open_resource() объекта приложения является удобной функцией-помощником, которая откроет ресурс, обеспечиваемый приложением. 
Эта функция открывает файл из места расположения ресурсов (в нашем случае папка blog), и позволяет вам из него читать. 
Мы используем её здесь для того, чтобы выполнить скрипт при установлении соединения с базой данных.

Объект соединения, который предоставляет SQLite может дать нам объект курсора. 
Для этого курсора существует метод для выполнения целого скрипта. В самом конце нам нужно лишь совершить (фиксировать) изменения. 
SQLite 3 и другие транзакционные базы данных не зафиксируют изменения, если вы явно об этом их не попросите."""
def init_db():
    with app.app_context():
        db = get_db()
        with app.open_resource('schema.sql', mode='r') as f:
            db.cursor().executescript(f.read())
        db.commit()
"""8.) Пишем функции представления. Всего понадобиться 4 таких функции.
а)Показать записи
Это представление показывает все записи, хранящиеся в базе данных. Оно соответствует главной странице вашего приложения,
и выбирает все заголовки и тексты из базы данных. Запись с наибольшим id (последняя по времени) будет наверху. 
Строки, возвращаемые курсором немного похожи на кортежи, так как мы используем фабрику строк sqlite3.Row
Функция представления передаёт записи в виде словаря шаблону show_entries.html и возвращает сформированное отображение."""
@app.route('/')
def show_entries():
    db = get_db()
    cur = db.execute('select title, text from entries order by id desc')
    entries = cur.fetchall()
    return render_template('show_entries.html', entries=entries)
"""
б)Добавление новой записи
Это представление позволяет пользователю, если он осуществил вход, добавлять новые записи. 
Оно реагирует только на запросы типа POST, а фактическая форма отображается на странице show_entries. 
Если всё работает хорошо, наше сообщение будет передано (flash()) следующему запросу и произойдёт возврат 
через перенаправление на страницу show_entries.

Замечание: здесь есть проверка на то, что пользователь вошёл (ключ внутри сессии logged_in присутствует и установлен в True)."""
@app.route('/add', methods=['POST'])
def add_entry():
    if not session.get('logged_in'):
        abort(401)
    db = get_db()
    db.execute('insert into entries (title, text) values (?, ?)',#?? - для безопасности приложения от SQL-инъекций.
                [request.form['title'], request.form['text']])
    db.commit()
    flash('New entry was successfully posted')
    return redirect(url_for('show_entries'))
"""
в)Вход
При входе производится проверка имя пользователя и пароля с значениями, хранимыми в конфигурации, и в сессии устанавливается 
ключ logged_in. Если пользователь зашёл успешно, этот ключ устанавливается в True, и пользователь возвращается обратно к странице 
show_entries. К тому же, появляется всплывающее сообщение, что он или она зашли успешно. 
При возникновении ошибки, шаблон об этом получает уведомление, и происходит повторный запрос 
у пользователя имени пользователя и пароля"""
@app.route('/login', methods=['GET', 'POST'])
def login():
    error = None
    if request.method == 'POST':
        if request.form['username'] != app.config['USERNAME']:
            error = 'Invalid username'
        elif request.form['password'] != app.config['PASSWORD']:
            error = 'Invalid password'
        else:
            session['logged_in'] = True
            flash('You were logged in')
            return redirect(url_for('show_entries'))
    return render_template('login.html', error=error)
"""
г)Выход
Функция выхода, с другой стороны, удаляет обратно этот ключ из сессии. 
Здесь мы используем ловкий трюк: если вы используете метод словаря pop() и передаёте ему второй параметр (по умолчанию), 
метод удаляет ключ из словаря при его наличии или ничего не делает если такого ключа нет. 
Это полезно, потому что теперь нам не надо делать проверку, вошёл ли пользователь или нет."""
@app.route('/logout')
def logout():
    session.pop('logged_in', None)
    flash('You were logged out')
    return redirect(url_for('show_entries'))
"""4.)Наконец, мы просто добавляем строчку в конце файла, которая запускает сервер, 
если мы хотим запустить этот файл как отдельное приложение:"""
if __name__ == '__main__':
    app.run()